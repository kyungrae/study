# Algorithm

## 코드와 데이터 분리

코드의 논리와 상관 없는 데이터는 가능한 분리한다.

```C
const string months[] = {"January", "Feburary", "March", ....}
const int dy[] = {1, 0, -1, 0};
const int dx[] = {0 ,1, 0, -1};
```

## 시간 복잡도

알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 입력의 크기에 대한 함수로 표현한 것이다.
전체 수행 시간에 큰 영향을 미치지 않는 상수 부분은 무시하고 반복문의 반복 수만 고려하게 된다.
가장 빨리 증가하는 항만을 남긴 채 나머지를 버린 O 표기법(Big-O Notation)으로 표기한다.

## 수학적 귀납법

1. 단계 나누기
2. 첫 단계 증명
3. 한 단계에서 증명하고 싶은 내용이 성립한다면, 다음 단계에서도 성립함을 보인다.

## 반복문 불변식

반복문의 내용이 한 번 실행될 때마다 중간 결과가 우리가 원하는 답으로 가는 길 위에 있는지를 명시하는 조건

1. 반복문 진입시에 불변식이 성립함을 보인다.
2. 반복문 내용이 불변식을 깨드리지 않음을 보인다.
3. 반복문 종료시에 불변식이 성립하면 정답을 구했음을 보인다.

## 귀류법

반대되는 상황을 가정하고 논리를 전개해서 결론이 잘못됐음을 찾아내는 증명 기법이다.
보통 어떤 선택이 항상 최선임을 증명하고자 할 때 사용된다.

## Problem & Subproblem

문제의 해결 방법을 만들 때, 단계 중 하나가 문제와 동일할 형식의 문제인 경우 단계 하나를 문제의 일부라고 말할 수 있다.

## Recursive function

동일한 작업이 반복될 때, 현재 작업은 직접 처리하고 이후 작업은 자기 자신을 호출해서 문제를 해결하는 함수이다.
문제를 더 이상 나눌 수 없는 경우 기저 조건(base case)이라고 한다.
재귀 함수를 구현할 때 기저 조건(base case)을 꼭 명시해야 한다.

## Brute-force

가능한 경우의 수를 일일이 나열해서 답을 찾는 방법

## Device-and-conquer

둘 이상의 부분 문제로 나눈 뒤 각 문제에 대한 답을 재귀 호출을 이용해 계산하고, 각 부분 문제의 답으로부터 전체 문제의 답을 계산한다.
분할 정복이 일반적인 재귀 호출과 다른 점은 문제를 한 조각과 나머지 전체로 나누는 대신 거의 같은 크기의 부분 문제로 나누는 것이다.
