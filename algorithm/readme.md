# Algorithm

어떤 작업이 주어졌을 때 컴퓨터가 이 작업을 해결하는 방법을 가리켜 알고리즘이라고 한다.

## 코드와 데이터 분리

코드의 논리와 상관 없는 데이터는 가능한 분리한다.

```C
const string months[] = {"January", "Feburary", "March", ....}
const int dy[] = {1, 0, -1, 0};
const int dx[] = {0 ,1, 0, -1};
```

## 알고리즘 분석

### 시간 복잡도

알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 입력의 크기에 대한 함수로 표현한 것이다.
전체 수행 시간에 큰 영향을 미치지 않는 상수 부분은 무시하고 반복문의 반복 수만 고려하게 된다.
가장 빨리 증가하는 항만을 남긴 채 나머지를 버린 O 표기법(Big-O Notation)으로 표기한다.

### 수학적 귀납법

1. 단계 나누기
2. 첫 단계 증명
3. 한 단계에서 증명하고 싶은 내용이 성립한다면, 다음 단계에서도 성립함을 보인다.

### 반복문 불변식

반복문의 내용이 한 번 실행될 때마다 중간 결과가 우리가 원하는 답으로 가는 길 위에 있는지를 명시하는 조건

1. 반복문 진입시에 불변식이 성립함을 보인다.
2. 반복문 내용이 불변식을 깨드리지 않음을 보인다.
3. 반복문 종료시에 불변식이 성립하면 정답을 구했음을 보인다.

### 귀류법

반대되는 상황을 가정하고 논리를 전개해서 결론이 잘못됐음을 찾아내는 증명 기법이다.
보통 어떤 선택이 항상 최선임을 증명하고자 할 때 사용된다.

## Brute-force

가능한 경우의 수를 일일이 나열해서 답을 찾는 방법

### Problem & Subproblem

문제의 해결 방법을 만들 때, 단계 중 하나가 문제와 동일할 형식의 문제인 경우 단계 하나를 문제의 일부라고 말할 수 있다.

### Recursive function

동일한 작업이 반복될 때, 현재 작업은 직접 처리하고 이후 작업은 자기 자신을 호출해서 문제를 해결하는 함수이다.
문제를 더 이상 나눌 수 없는 경우 기저 조건(base case)이라고 한다.
재귀 함수를 구현할 때 기저 조건(base case)을 꼭 명시해야 한다.

## Device-and-conquer

둘 이상의 부분 문제로 나눈 뒤 각 문제에 대한 답을 재귀 호출을 이용해 계산하고, 각 부분 문제의 답으로부터 전체 문제의 답을 계산한다.
분할 정복이 일반적인 재귀 호출과 다른 점은 문제를 한 조각과 나머지 전체로 나누는 대신 거의 같은 크기의 부분 문제로 나누는 것이다.

## Dyanmic programing

어떤 부분 문제는 두 개 이상의 문제를 푸는 데 사용될 수 있기 때문에, 이 문제의 답을 여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용함으로써 알고리즘 속도를 증가시킬 수 있다.
각 문제의 답을 저장하기 위한 메모리 장소를 cache라고 부른다.
두 번 이상 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblems)라고 부른다.

### Memoization

함수의 결과를 저장하는 장소를 마련해 두고, 한 번 계산한 값을 저장해 뒀다 재활용하는 최적화 기법을 메모이제이션이라고 한다.

### Referential transparency

함수의 반환 값이 그 입력 값만으로 결정되는지의 여부를 참조적 투명성이라고 부른다.
메모이제이션은 참조적 투명 함수의 경우에만 적용할 수 있다.

### Optimal substructure

최적 부분 구조는 어떤 문제와 분할 방식에 성립하는 조건이다.
각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 얻어낼 수 있을 경우 이 조건이 성립한다.
