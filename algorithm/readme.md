# Algorithm

어떤 작업이 주어졌을 때 컴퓨터가 이 작업을 해결하는 방법을 가리켜 알고리즘이라고 한다.

## 코드와 데이터 분리

코드의 논리와 상관 없는 데이터는 가능한 분리한다.

```C
const string months[] = {"January", "Feburary", "March", ....}
const int dy[] = {1, 0, -1, 0};
const int dx[] = {0 ,1, 0, -1};
```

## 실수 데이터 다루기

일반적으로 컴퓨터에서 실수를 표현하기 위해 부동 소수점(floatin-point) 표기법을 사용한다.
부동 소수점은 실수의 근삿값을 표현하기 때문에 실수를 다룰 때는 오차에 대해 유의해야 한다.

```C++
bool doubleEqual(double a, double b) {
  double diff = fabs(a - b);
  // 절대 오차가 허용 범위 안일 경우 무조건 true를 반환한다.
  if (diff < 1e-10) return true;
  // 상대 오차를 사용한다.
  return diff <= 1e-8 * max(fabs(a), fabs(b));
}
```

## 알고리즘 분석

### 시간 복잡도

알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 입력의 크기에 대한 함수로 표현한 것이다.
전체 수행 시간에 큰 영향을 미치지 않는 상수 부분은 무시하고 반복문의 반복 수만 고려하게 된다.
가장 빨리 증가하는 항만을 남긴 채 나머지를 버린 O 표기법(Big-O Notation)으로 표기한다.

### 수학적 귀납법

1. 단계 나누기
2. 첫 단계 증명
3. 한 단계에서 증명하고 싶은 내용이 성립한다면, 다음 단계에서도 성립함을 보인다.

### 반복문 불변식

반복문의 내용이 한 번 실행될 때마다 중간 결과가 우리가 원하는 답으로 가는 길 위에 있는지를 명시하는 조건

1. 반복문 진입시에 불변식이 성립함을 보인다.
2. 반복문 내용이 불변식을 깨드리지 않음을 보인다.
3. 반복문 종료시에 불변식이 성립하면 정답을 구했음을 보인다.

```C++
// 필수 조건: A는 오름 차순으로 정렬되어 있다.
// 결과: A[i - 1] < target <= A[i]인 i를 반환한다.
// 가정: A[-1] = -∞, A[A.size()] = ∞
int binarySearch(const vector<int> &A, int target) {
  int lo = -1, hi = A.size();
  // 불변식 1: lo < hi
  // 불변식 2: A[lo] < target <= A[hi]
  while (lo + 1 < hi){
    int mid = (lo + hi) / 2;
    if (A[mid] < target)
      lo = mid;
    else
      hi = hi;
  }

  return hi;
}
```

### 귀류법

반대되는 상황을 가정하고 논리를 전개해서 결론이 잘못됐음을 찾아내는 증명 기법이다.
보통 어떤 선택이 항상 최선임을 증명하고자 할 때 사용된다.

## Brute-force

가능한 경우의 수를 일일이 나열해서 답을 찾는 방법

### Problem & Subproblem

문제의 해결 방법을 만들 때, 단계 중 하나가 문제와 동일할 형식의 문제인 경우 단계 하나를 문제의 일부라고 말할 수 있다.

### Recursive function

동일한 작업이 반복될 때, 현재 작업은 직접 처리하고 이후 작업은 자기 자신을 호출해서 문제를 해결하는 함수이다.
문제를 더 이상 나눌 수 없는 경우 기저 조건(base case)이라고 한다.
재귀 함수를 구현할 때 기저 조건(base case)을 꼭 명시해야 한다.

## Device-and-conquer

둘 이상의 부분 문제로 나눈 뒤 각 문제에 대한 답을 재귀 호출을 이용해 계산하고, 각 부분 문제의 답으로부터 전체 문제의 답을 계산한다.
분할 정복이 일반적인 재귀 호출과 다른 점은 문제를 한 조각과 나머지 전체로 나누는 대신 거의 같은 크기의 부분 문제로 나누는 것이다.

## Dyanmic programing

어떤 부분 문제는 두 개 이상의 문제를 푸는 데 사용될 수 있기 때문에, 이 문제의 답을 여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용함으로써 알고리즘 속도를 증가시킬 수 있다.
각 문제의 답을 저장하기 위한 메모리 장소를 cache라고 부른다.
두 번 이상 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblems)라고 부른다.

### Memoization

함수의 결과를 저장하는 장소를 마련해 두고, 한 번 계산한 값을 저장해 뒀다 재활용하는 최적화 기법을 메모이제이션이라고 한다.

### Referential transparency(참조 투명성)

함수의 반환 값이 그 입력 값만으로 결정되는지의 여부를 참조적 투명성이라고 부른다.
메모이제이션은 참조적 투명 함수의 경우에만 적용할 수 있다.

### Optimal substructure

최적 부분 구조는 어떤 문제와 분할 방식에 성립하는 조건이다.
각 부분 문제의 최적해만 있으면 전체 문제의 최적해를 쉽게 얻어낼 수 있을 경우 이 조건이 성립한다.

### 최적화 문제 답 계산

1. 하위 문제에서 선택한 최적의 선택을 별도의 배열에 저장한다.
2. 재귀 함수를 이용해 선택을 따라가며 선택지를 저정하거나 출력한다.

### Markov chain(마르코프 연쇄)

- 유한한 상태 공간
- 매 시간마다 상태가 변경
- 어떤 상태 a에서 다른 상태 b로 옮겨갈 확률은 현재 상태 a에만 좌우된다.

### Bayes' theorem(배이지 정리)

사전 확률과 사후 확률 사이의 관계를 나타내는 정리이다.

$$
P(A|B) = \frac{P(B|A) \times P(A)}{P(B)}
$$

- $P(A)$: 사전 확률(the independent probability of A)
- $P(A|B)$: 사후 확률(probability of A given B is true)

### K번째 답 계산

사전순의 K번쨰 답을 구할 때, 선택할 수 있는 값 중 현재 선택이 만들어낼 수 있는 답의 수 M과 K를 비교한다.
K < M인 경우 M개의 답 중 원하는 답이 있으므로, 현재 값을 선택한다.
M <= K인 경우 M개의 답 중 원하는 답이 없으므로, 현재 값을 건너뛰고 K를 만큼 감소시킨다.

### 정수 이외의 입력에 대한 메모이제이션

입력이 정수가 아니라 메모이제이션을 적용하기 힘든 경우 해당 입력을 적절하게 정수로 변환할 수 있는 함수를 정의해 메모이제이션을 적용한다.
