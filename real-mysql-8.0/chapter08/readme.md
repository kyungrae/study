# 8. 인덱스

## 8.1 디스크 읽기 방식

CPU나 메모리처럼 전기적 특성을 띤 장치의 성능은 빠른 속도로 발전했지만 디스크 같은 기계식 장치의 성능은 제한적으로 발전했다.
최근에는 자기 디스크 원판에 의존하는 HDD보다 SSD가 많이 활용되고 있지만 Secondary storage I/O는 컴퓨터에서 가장 느린 부분이다.
데이터베이스의 성능 튜닝은 어떻게 Secondary storage I/O를 줄이느냐가 관건일 때가 많다.

### 8.1.2 랜덤 I/O와 순차 I/O

순차 I/O는 3개의 페이지를 디스크에 기록하기 위해 1번 시스템 콜을 요청한다.
랜덤 I/O는 3개의 페이지를 디스크에 기록하기 위해 3번의 시스템 콜을 요청한다.
순차 I/O는 디스크 헤드를 1번 움직이지만, 랜덤 I/O는 디스크 헤드를 3번 움직인다.
데이터베이스 대부분의 작업은 작은 데이터를 빈번히 읽고 쓰기 때문에 MySQL 서버에는 그룹 커밋이나 버이너리 로그 버퍼 또는 InnoDB 로그 버퍼 등의 기능이 내장돼 있다.

인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O를 사용하며 풀 테이블 스캔은 순차 I/O를 사용한다.
그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 유도할 때도 있다.

## 8.2 인덱스란

데이터를 빠르게 검색하기 위해 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스를 만들어 두는 것이다.

- B-Tree 알고리즘
- Hash 인덱스 알고리즘

## 8.3 B-Tree 인덱스

B-Tree는 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.
MySQL의 B-Tree 인덱스는 실제 칼럼 값이 1MB이더라도 1MB 전체의 값을 인덱스 키로 사용하는 것이 아니라 1,000바이트(MyISAM) 또는 3,072바이트까지만 잘러서 인덱스 키로 사용한다.

### 8.3.1 구조 및 특성

B-Tree는 트리 구조의 최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어 있는 형태다.
트리 구조의 가장 하위에 있는 노드를 리프 노드하 하고, 트리 구조에서 루트 노드도 아니고 리프 노드도 아닌 중간의 노드를 브랜치 노드라고 한다.
데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 데이터 레코드를 찾아가기 위한 주소값을 가지고 있다.

![B-Tree 인덱스 구조](./index.png)

InnoDB 스토리지 엔젠에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야 한다.

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제

#### 8.3.2.1 인덱스 키 추가

B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree 상의 적절할 위치를 검색해야 한다.
저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.
리포 노드가 꽉 차서 더는 저장할 수 없을 대는 리포 노드가 분리(Split)돼야 하는데, 이는 상위 브랜치 노드까지 작업 범위가 넓어진다.
이러한 작업 탓에 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 드는 것으로 알려졌다.

테이블에 레코드를 추가하는 작업 비용을 1이라고 가정하면 해당 테이블의 인덱스에 키를 추가하는 작업 비용을 1.5 정도로 예측하는 것이다.
일반적으로 테이블에 인덱스가 3개가 있다면 이때 테이블에 인덱스가 하나도 없는 경우는 작업 비용이 1이고, 3개인 경우에는 5.5 정도의 비용 정도로 예측한다.

#### 8.3.2.2 인덱스 키 삭제

삭제의 경우 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 삭제 마크를 하면 작업이 완료된다.
삭제 마킹된 인덱스 키 공간은 계속 방치하거나 재활용할 수 있다.

#### 8.3.2.3 인덱스 키 변경

변경의 경우 먼저 키 값을 삭제하고 다시 새로운 키 값을 추가하는 작업을 수행한다.

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

#### 8.3.3.1 인덱스 키 값의 크기

B-Tree 자식 노드의 개수는 인덱스의 페이지 크기와 키 값의 크기에 따라 결정된다.
인덱스를 구성하는 키의 크기가 커지면 디스크로부터 읽어야하는 횟수가 늘어나고, 메모리 효울도 떨어진다.
$$B-Tree\,자식\,노드\,개수 = \frac{인덱스\,페이지\,사이즈}{인덱스\,키의\,크기 + 자식\,노드\,주소\,크기} = \frac{16KB}{16B + 12B} $$

#### 8.3.3.3 Seletivity(선택도)

인덱스에서 Seletivitiy(선택도) 또는 Cardinality(기수성)은 거의 같은 의미로 사용되며, 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.
저첸 인덱스 키 값은 100개인데, 그중에서 유니크한 값의 수는 10개라면 기수성은 10이다.
인덱스는 기수성이 높을수록 검색 대상이 줄어들기 때문에 빠르게 처리된다.

#### 8.3.3.4 읽어야하는 레코드의 건수

일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업인 것으로 예측한다.
인덱스를 통해 읽어야 할 레코드의 건수(옵티마이저가 판단한 예상 건수)가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 필터링하는 방식으로 처리하는 것이 효율적이다.

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

#### 8.3.4.1 인덱스 레인지 스캔

인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.
검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이 레인지 스캔이라고 표현한다.

1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다.(인덱스 탐색)
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다.(인덱스 스캔)
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽오온다.

쿼리가 필요로 하는 데이터에 따라 3번 과정은 필요하지 않을 수도 있는데, 이를 **커버링 인덱스**라고 한다. 커버링 인덱스로 처리되는 쿼리는 디스크의 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 상당히 줄어들고 성능은 그만큼 빨라진다.

#### 8.3.4.2 인덱스 풀 스캔

인덱스의 크기는 테이블의 크기보다 작으므로 직접 테이블을 처음부터 끝까지 읽는 것보다는 인덱스만 읽는 것이 효율적이다.
쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용된다.
인덱스뿐만 아니라 데이터 레코드까지 모두 읽어야 한다면 절대 이 방식으로 처리되지 않는다.

#### 8.3.4.3 인덱스 루스 스캔

인덱스 스캔은 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시(skip)하고 다음으로 넘어가는 형태로 처리된다.
일반적으로 GROUP BY 또는 집합 함수 가운데 MAX() 또는 MIN() 함수에 대해 최적화를 하는 경우에 사용된다.

```SQL
-- INDEX (dept_no, emp_no)
SELECT dept_no, MIN(emp_no) FROM dept_emp 
WHERE dept_no BETWEEN 'd002' AND 'd004' GROUP BY dept_no;
```

#### 8.3.4.4 인덱스 스킵 스캔

다중 칼럼 인덱스의 선행 칼럼을 건너뛰어서 나머지 칼럼만으로도 인덱스 검색이 가능하다.
옵티마이저는 우선 gender 칼럼에서 유니크한 값을 모두 조회해서 주어진 쿼리에 gender 칼럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리한다.

- WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함
- 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함

```SQL
-- INDEX (gender, birth_date)

-- 입력 쿼리
SELECT gender, birth_date FROM employees WHERE birth_date >= '1965-02-01';

-- 최적화 쿼리
SELECT gender, birth_date FROM employees WHERE gender = 'M' AND birth_date >= '1965-02-01';
SELECT gender, birth_date FROM employees WHERE gender = 'F' AND birth_date >= '1965-02-01';
```

### 8.3.5 다중 칼럼(Multi-column) 인덱스

두 개 이상의 칼럼으로 구성된 인덱스를 다중 칼럼 인덱스(복합 칼럼 인덱스)라고 하며, 또한 2개 이상의 칼럼이 연결됐다고 해서 Concatenated Index라고도 한다.
다중 칼럼 인덱스에서 중요한 것은 인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬돼 있다는 것이다.

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

인덱스를 생성할 때 설정한 정렬 규칙에 따라서 인덱스의 키 값은 항상 오름차순이거나 내림차순으로 정렬되어 저장된다.
인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어내는 실행 계획에 따라 결정된다.

![인덱스 정렬](./order_index.png)

- Asecending inde: 작은 값의 인덱스 키가 B-Tree 왼쪽으로 정령 인덱스
- Descending index: 큰 값의 인덱스 키가 B-Tree 왼쪽으로 정령 인덱스
- Forward index scan: 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔
- Backward index scan: 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔

역순 정렬 쿼리가 정순 정렬 쿼리보다 약 25% 더 시간이 걸린다.

#### 8.3.6.1 페이지 잠금이 Forward index scan에 적합한 구조

B-Tree 리프 페이지는 Double linked list로 연결되어 있기 때문에, 어느 방향이든 이동 자체는 차이가 없다.
하지만 InnoDB 스토리지 엔진에서 페이지 잠금 과정에서 데드락을 방지하기 위해 B-Tree의 왼쪽에서 오른쪽 순서로만 잠금을 획득하도록 하고 있다.
그래서 Forward index scan에서는 다음 페이지 잠금 획득이 간단하지만, Backward index scan에서는 이전 페이지 잠금 획득이 복잡하다.

#### 8.3.6.2 페이지 내에서 인덱스 레코드는 단방향으로만 연결된 구조

일반적으로 인덱스 리프 노드 페이지에는 약 600개의 레코드가 저장될 수 있다.
InnoDB 스토리지 엔진은 하나의 페이지내에서 순차적으로 정렬된 레코드 4~8개 정도씩을 묶어서 대표 키(가장 큰 인덱스 엔트리 키 값)을 선정한다.
그리고 이 대표 키들만 모아서 별도의 리스트를 관리하는데, 이를 **페이지 디렉토리**(Page directory)라고 한다.
하나의 페이지에서 특정 키 값을 검새할 때 Page directory를 이용해 바이너리 서치 방식으로 검색 대상 키를 포함하는 대표 키를 검색한다.
대표 키를 찾으면 그때부터 인덱스 키값 순서대로 연결된 Linked list를 이용해서 대상 레코드를 검색하게 된다.
그런데 페이지 내부 레코드(인덱스 엔트리)들은 Single linked list 구조로 구성되어 있다.

역순 정렬 쿼리가 많은 레코드를 빈번하게 조회하거나 인덱스의 안쪽 또는 뒤쪽만 집중적으로 읽어서 인덱스의 특정 페이지 잠금이 병목이 될 것으로 예상된다면 쿼리에서 사용하는 정렬 순서대로 인덱스를 생성하는 것이 효율적이다.

![페이지 디렉토리](./page_directory.png)

### 8.3.7 B-Tree 인덱스의 가용성과 효율성

```SQL
SELECT * FROM dept_emp WHERE dept_no = 'd002' and emp_no >= 10114;
```

- INDEX A (dept_no, emp_no)  
- INDEX B (emp_no, dept_no)

공식 명칭은 아니지만 INDEX A는 두 조건이 모두 작업 범위를 결정하는 조건을 "작업 범위 결정 조건"이라고 표현한다.
INDEX B의 dept_no == d002' 조건 같이 작업의 범위를 줄이지 못하고 거름종이 역할만 하는 조건을 "필터링 조건" 또는 "체크 조건"이라고 표현한다.

다른 일반적인 DBMS에서는 NULL 값이 인덱스에 저장되지 않지만 MySQL에서는 NULL 값도 인덱스에 저장된다.

## 8.4 R-Tree 인덱스

공간 인덱스는 R-Tree 인덱스 알고리즘을 이용해 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스다.
일반적으로 WGS84(GPS) 기준의 위도, 경도 좌표 저장에 주로 사용된다.
하지만 CAD/CAM 소프트웨어 또는 회로 디자인 등과 같이 좌표 시스템에 기반을 둔 정보에 대해서는 모두 적용할 수 있다.

MBR이란 "Mininum Bounding Rectangle"의 약자로 해당 도형을 감싸는 최소 크기의 사각형을 의미한다.

## 8.5 전문 검색 인덱스

전문 검색에서는 문서 본문의 내용에서 사용자가 검색하게 될 키워드를 분석해 내고, 빠른 검색용으로 사용할 수 있게 이러한 키워드로 인덱스로 구축한다.
키워드의 분석 및 인덱스 구축에는 여러가지 방법이 있을 수 있다.
전문 검색 인덱스는 문서의 키워드를 인덱싱하는 기법에 따라 크게 단어의 어근 분석과 n-gram 분석 알고리즘으로 구분할 수 있다.

### 어근 분석

어근 분석은 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업이다.

### n-gram

본문을 무조건 몇 글자씩 잘라서 인덱싱하는 방법이다.

### 불용어

검색에서 별 가치가 없는 단어를 모두 필터링해서 제거하는 작업이다.

## 8.6 함수 기반 인덱스

### 8.6.1 가상 칼럼을 이용한 인덱스

가상 칼럼은 테이블에 새로운 칼럼을 추가하는 것과 같은 효과를 내기 때문에 실제 테이블 구조가 변경된다는 단점이 있다.

```SQL
CREATE TABLE user(
  user_id BIGINT,
  first_name VARCHAR(10),
  last_name VARCHAR(10),
  PRIMARY KEY (user_id)
);

ALTER TABLE user
  ADD full_name VARCHAR(30) AS (CONCAT(first_name,' ',last_name)) VIRTUAL,
  ADD INDEX ix_fullname (full_name);
```

### 8.6.2 함수를 이용한 인덱스

함수를 직접 사용하는 인덱스는 테이블의 구조는 변경하지 않고, 계산된 결괏값의 검색을 빠르게 만들준다.
함수 기반 인덱스를 제대로 활용하려면 반드시 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용돼야 한다.

```SQL
CREATE TABLE user(
  user_id BIGINT,
  first_name VARCHAR(10),
  last_name VARCHAR(10),
  PRIMARY KEY (user_id),
  INDEX ix_fullname ((CONCAT(first_name,' ',last_name)))
);

SELECT * FROM user WHERE CONCAT(first_name,' ',last_name)='Matt Lee';
```

## 8.7 멀티 밸류 인덱스

하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스다.

```SQL
CREATE TABLE user(
  user_id BIGINT,
  first_name VARCHAR(10),
  last_name VARCHAR(10),
  credit_info JSON,
  INDEX mx_creditscorees ( (CAST(credit_info->'$.credit_scores' AS UNSIGNED ARRAY)) )

INSERT INTO user VALUES (1, 'Matt', 'Lee', '{"credit_scores":[360, 353, 351]}');

SELECT * FROM user WHERE 360 MEMBER OF(credit_info->'$.credit_scores');
```

## 8.8 클러스터링 인덱스

## 8.9 유니크 인덱스

## 8.10 외래키
